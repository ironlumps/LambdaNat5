
==================== FINAL INTERFACE ====================
2019-10-02 22:50:42.7225964 UTC

interface LambdaNat-0.1.0.0-EvitBjaHhSP7BnBJ5PUt9C:ErrM 8064
  interface hash: bca721188d1854be563e06a692bdf54f
  ABI hash: 746d270a2e0d61a274cbfd30de8cf42c
  export-list hash: 5df018d0238e03fcffb629f6e5868455
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 14c2cc79705a4419f265d275e12b2327
  opt_hash: 6faf2de08de32d19db9870899d88e59a
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  ErrM.Err{ErrM.Bad ErrM.Ok}
module dependencies:
package dependencies: base-4.12.0.0* ghc-prim-0.5.3
                      integer-gmp-1.0.2.0
orphans: base-4.12.0.0:GHC.Float base-4.12.0.0:GHC.Base
family instance modules: base-4.12.0.0:Control.Applicative
                         base-4.12.0.0:Data.Functor.Const
                         base-4.12.0.0:Data.Functor.Identity base-4.12.0.0:Data.Monoid
                         base-4.12.0.0:Data.Semigroup.Internal base-4.12.0.0:GHC.Generics
                         base-4.12.0.0:GHC.IO.Exception
import  -/  base-4.12.0.0:Control.Applicative 37ad1ecb7adc211899b18378548196ee
import  -/  base-4.12.0.0:Control.Monad be24c6211d7cb61f18d2854428d9a69e
import  -/  base-4.12.0.0:GHC.Base 954f4c258d193fab7048a63bfeb56dcf
import  -/  base-4.12.0.0:GHC.Read 50b14d50d8c271bd5efd5062fd745876
import  -/  base-4.12.0.0:GHC.Show 48dce8b8129312101170e57c24f3ecbd
import  -/  base-4.12.0.0:Prelude aea9afd24db8aed3563d7d850ea453c0
import  -/  base-4.12.0.0:Text.ParserCombinators.ReadPrec 2348279db1e8773e69ed9cb8b4d700e7
import  -/  base-4.12.0.0:Text.Read.Lex 789da997e47bdc6e40b6cb4d668f10b7
import  -/  ghc-prim-0.5.3:GHC.Classes 6002495dc43e58d28c87e5e5e058752a
import  -/  ghc-prim-0.5.3:GHC.Types 57064c9f957b09bc2e360061ad5cae0b
a1a89eb5c3e343b85b60ab4faac95fa2
  $fAlternativeErr :: GHC.Base.Alternative ErrM.Err
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ ErrM.Err
                  ErrM.$fApplicativeErr
                  ErrM.$fAlternativeErr_$cmzero
                  ErrM.$fAlternativeErr_$cmplus
                  ErrM.$fAlternativeErr_$csome
                  ErrM.$fAlternativeErr_$cmany -}
a1a89eb5c3e343b85b60ab4faac95fa2
  $fAlternativeErr1 :: ErrM.Err [a]
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (\ @ a -> ErrM.Ok @ [a] (GHC.Types.[] @ a)) -}
41ceaa84530faa2e33e47a4d4ccb155c
  $fAlternativeErr2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ErrM.$fAlternativeErr3) -}
71b668380ddff25f988944c5f18fbfd9
  $fAlternativeErr3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Err.mzero"#) -}
a1a89eb5c3e343b85b60ab4faac95fa2
  $fAlternativeErr_$cmany :: ErrM.Err a -> ErrM.Err [a]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (v :: ErrM.Err a) ->
                 letrec {
                   many_v :: ErrM.Err [a]
                   = case v of wild {
                       ErrM.Ok a1
                       -> case many_v of wild1 {
                            ErrM.Ok a2 -> ErrM.Ok @ [a] (GHC.Types.: @ a a1 a2)
                            ErrM.Bad s -> ErrM.$fAlternativeErr1 @ a }
                       ErrM.Bad s -> ErrM.$fAlternativeErr1 @ a }
                 } in
                 many_v) -}
a1a89eb5c3e343b85b60ab4faac95fa2
  $fAlternativeErr_$cmplus :: ErrM.Err a -> ErrM.Err a -> ErrM.Err a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a (ds :: ErrM.Err a) (y :: ErrM.Err a) ->
                 case ds of wild { ErrM.Ok ipv -> wild ErrM.Bad ds1 -> y }) -}
a1a89eb5c3e343b85b60ab4faac95fa2
  $fAlternativeErr_$cmzero :: ErrM.Err a
  {- Strictness: m2,
     Unfolding: (\ @ a -> ErrM.Bad @ a ErrM.$fAlternativeErr2) -}
a1a89eb5c3e343b85b60ab4faac95fa2
  $fAlternativeErr_$csome :: ErrM.Err a -> ErrM.Err [a]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,U>,
     Unfolding: (\ @ a (v :: ErrM.Err a) ->
                 letrec {
                   some_v :: ErrM.Err [a]
                   = case v of wild {
                       ErrM.Ok a1
                       -> case some_v of wild1 {
                            ErrM.Ok ipv -> ErrM.Ok @ [a] (GHC.Types.: @ a a1 ipv)
                            ErrM.Bad ds
                            -> ErrM.Ok @ [a] (GHC.Types.: @ a a1 (GHC.Types.[] @ a)) }
                       ErrM.Bad s -> ErrM.Bad @ [a] s }
                 } in
                 some_v) -}
a1a89eb5c3e343b85b60ab4faac95fa2
  $fApplicativeErr :: GHC.Base.Applicative ErrM.Err
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ ErrM.Err
                  ErrM.$fFunctorErr
                  ErrM.Ok
                  ErrM.$fApplicativeErr_$c<*>
                  ErrM.$fApplicativeErr_$cliftA2
                  ErrM.$fApplicativeErr_$c*>
                  ErrM.$fApplicativeErr_$c<* -}
a1a89eb5c3e343b85b60ab4faac95fa2
  $fApplicativeErr_$c*> :: ErrM.Err a -> ErrM.Err b -> ErrM.Err b
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (a1 :: ErrM.Err a) (a2 :: ErrM.Err b) ->
                 case a1 of wild {
                   ErrM.Ok a4 -> a2 ErrM.Bad s -> ErrM.Bad @ b s }) -}
a1a89eb5c3e343b85b60ab4faac95fa2
  $fApplicativeErr_$c<* :: ErrM.Err a -> ErrM.Err b -> ErrM.Err a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (x :: ErrM.Err a) (ds :: ErrM.Err b) ->
                 case x of wild {
                   ErrM.Ok a1
                   -> case ds of wild1 {
                        ErrM.Ok a2 -> ErrM.Ok @ a a1 ErrM.Bad s -> ErrM.Bad @ a s }
                   ErrM.Bad s -> ErrM.Bad @ a s }) -}
a1a89eb5c3e343b85b60ab4faac95fa2
  $fApplicativeErr_$c<*> ::
    ErrM.Err (a -> b) -> ErrM.Err a -> ErrM.Err b
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (ds :: ErrM.Err (a -> b)) (ds1 :: ErrM.Err a) ->
                 case ds of wild {
                   ErrM.Ok f
                   -> case ds1 of wild1 {
                        ErrM.Ok a1 -> ErrM.Ok @ b (f a1) ErrM.Bad s -> ErrM.Bad @ b s }
                   ErrM.Bad s -> ErrM.Bad @ b s }) -}
a1a89eb5c3e343b85b60ab4faac95fa2
  $fApplicativeErr_$cliftA2 ::
    (a -> b -> c) -> ErrM.Err a -> ErrM.Err b -> ErrM.Err c
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(U)><L,1*U>,
     Unfolding: (\ @ a @ b @ c (f1 :: a -> b -> c) (x :: ErrM.Err a) ->
                 let {
                   ds :: ErrM.Err (b -> c)
                   = case x of wild {
                       ErrM.Ok a1 -> ErrM.Ok @ (b -> c) (f1 a1)
                       ErrM.Bad s -> ErrM.Bad @ (b -> c) s }
                 } in
                 \ (ds1 :: ErrM.Err b) ->
                 case ds of wild {
                   ErrM.Ok f
                   -> case ds1 of wild1 {
                        ErrM.Ok a1 -> ErrM.Ok @ c (f a1) ErrM.Bad s -> ErrM.Bad @ c s }
                   ErrM.Bad s -> ErrM.Bad @ c s }) -}
a1a89eb5c3e343b85b60ab4faac95fa2
  $fEqErr :: GHC.Classes.Eq a => GHC.Classes.Eq (ErrM.Err a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: GHC.Classes.Eq a).
                  @ (ErrM.Err a)
                  (ErrM.$fEqErr_$c== @ a v)
                  (ErrM.$fEqErr_$c/= @ a v) -}
a1a89eb5c3e343b85b60ab4faac95fa2
  $fEqErr_$c/= ::
    GHC.Classes.Eq a => ErrM.Err a -> ErrM.Err a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (x :: ErrM.Err a)
                   (y :: ErrM.Err a) ->
                 case x of wild {
                   ErrM.Ok a1
                   -> case y of wild1 {
                        ErrM.Ok b1
                        -> case GHC.Classes.== @ a $dEq a1 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.True
                             GHC.Types.True -> GHC.Types.False }
                        ErrM.Bad ipv -> GHC.Types.True }
                   ErrM.Bad a1
                   -> case y of wild1 {
                        ErrM.Ok ipv -> GHC.Types.True
                        ErrM.Bad b1
                        -> case GHC.Base.eqString a1 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.True
                             GHC.Types.True -> GHC.Types.False } } }) -}
a1a89eb5c3e343b85b60ab4faac95fa2
  $fEqErr_$c== ::
    GHC.Classes.Eq a => ErrM.Err a -> ErrM.Err a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (ds :: ErrM.Err a)
                   (ds1 :: ErrM.Err a) ->
                 case ds of wild {
                   ErrM.Ok a1
                   -> case ds1 of wild1 {
                        ErrM.Ok b1 -> GHC.Classes.== @ a $dEq a1 b1
                        ErrM.Bad ipv -> GHC.Types.False }
                   ErrM.Bad a1
                   -> case ds1 of wild1 {
                        ErrM.Ok ipv -> GHC.Types.False
                        ErrM.Bad b1 -> GHC.Base.eqString a1 b1 } }) -}
a1a89eb5c3e343b85b60ab4faac95fa2
  $fFunctorErr :: GHC.Base.Functor ErrM.Err
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ ErrM.Err ErrM.$fFunctorErr_$cfmap ErrM.$fFunctorErr_$c<$ -}
a1a89eb5c3e343b85b60ab4faac95fa2
  $fFunctorErr_$c<$ :: a -> ErrM.Err b -> ErrM.Err a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (x :: a) (eta :: ErrM.Err b) ->
                 case eta of wild {
                   ErrM.Ok a1 -> ErrM.Ok @ a x ErrM.Bad s -> ErrM.Bad @ a s }) -}
a1a89eb5c3e343b85b60ab4faac95fa2
  $fFunctorErr_$cfmap :: (a -> b) -> ErrM.Err a -> ErrM.Err b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(U)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (f :: a -> b) (m1 :: ErrM.Err a) ->
                 case m1 of wild {
                   ErrM.Ok a1 -> ErrM.Ok @ b (f a1) ErrM.Bad s -> ErrM.Bad @ b s }) -}
a1a89eb5c3e343b85b60ab4faac95fa2
  $fMonadErr :: GHC.Base.Monad ErrM.Err
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ ErrM.Err
                  ErrM.$fApplicativeErr
                  ErrM.$fMonadErr_$c>>=
                  ErrM.$fMonadErr_$c>>
                  ErrM.Ok
                  ErrM.Bad -}
a1a89eb5c3e343b85b60ab4faac95fa2
  $fMonadErr_$c>> :: ErrM.Err a -> ErrM.Err b -> ErrM.Err b
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a @ b (m1 :: ErrM.Err a) (k :: ErrM.Err b) ->
                 case m1 of wild {
                   ErrM.Ok a1 -> k ErrM.Bad s -> ErrM.Bad @ b s }) -}
a1a89eb5c3e343b85b60ab4faac95fa2
  $fMonadErr_$c>>= :: ErrM.Err a -> (a -> ErrM.Err b) -> ErrM.Err b
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*C1(U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (ds :: ErrM.Err a) (f :: a -> ErrM.Err b) ->
                 case ds of wild {
                   ErrM.Ok a1 -> f a1 ErrM.Bad s -> ErrM.Bad @ b s }) -}
a1a89eb5c3e343b85b60ab4faac95fa2
  $fMonadPlusErr :: GHC.Base.MonadPlus ErrM.Err
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ ErrM.Err
                  ErrM.$fAlternativeErr
                  ErrM.$fMonadErr
                  ErrM.$fAlternativeErr_$cmzero
                  ErrM.$fAlternativeErr_$cmplus -}
a1a89eb5c3e343b85b60ab4faac95fa2
  $fOrdErr :: GHC.Classes.Ord a => GHC.Classes.Ord (ErrM.Err a)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(1*U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: GHC.Classes.Ord a).
                  @ (ErrM.Err a)
                  (ErrM.$fOrdErr_$cp1Ord @ a v)
                  (ErrM.$fOrdErr_$ccompare @ a v)
                  (ErrM.$fOrdErr_$c< @ a v)
                  (ErrM.$fOrdErr_$c<= @ a v)
                  (\ (a1 :: ErrM.Err a) (b :: ErrM.Err a) ->
                   ErrM.$fOrdErr_$c< @ a v b a1)
                  (ErrM.$fOrdErr_$c>= @ a v)
                  (ErrM.$fOrdErr_$cmax @ a v)
                  (ErrM.$fOrdErr_$cmin @ a v) -}
a1a89eb5c3e343b85b60ab4faac95fa2
  $fOrdErr_$c< ::
    GHC.Classes.Ord a => ErrM.Err a -> ErrM.Err a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
     Unfolding: (\ @ a
                   ($dOrd :: GHC.Classes.Ord a)
                   (a1 :: ErrM.Err a)
                   (b :: ErrM.Err a) ->
                 case a1 of wild {
                   ErrM.Ok a2
                   -> case b of wild1 {
                        ErrM.Ok b1 -> GHC.Classes.< @ a $dOrd a2 b1
                        ErrM.Bad ipv -> GHC.Types.True }
                   ErrM.Bad a2
                   -> case b of wild1 {
                        ErrM.Ok ipv -> GHC.Types.False
                        ErrM.Bad b1 -> GHC.Classes.$fOrd[]_$s$c<1 a2 b1 } }) -}
a1a89eb5c3e343b85b60ab4faac95fa2
  $fOrdErr_$c<= ::
    GHC.Classes.Ord a => ErrM.Err a -> ErrM.Err a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
     Unfolding: (\ @ a
                   ($dOrd :: GHC.Classes.Ord a)
                   (a1 :: ErrM.Err a)
                   (b :: ErrM.Err a) ->
                 case b of wild {
                   ErrM.Ok a2
                   -> case a1 of wild1 {
                        ErrM.Ok b1
                        -> case GHC.Classes.< @ a $dOrd a2 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.True
                             GHC.Types.True -> GHC.Types.False }
                        ErrM.Bad ipv -> GHC.Types.False }
                   ErrM.Bad a2
                   -> case a1 of wild1 {
                        ErrM.Ok ipv -> GHC.Types.True
                        ErrM.Bad b1
                        -> case GHC.Classes.$fOrd[]_$s$ccompare1 a2 b1 of wild2 {
                             DEFAULT -> GHC.Types.True GHC.Types.LT -> GHC.Types.False } } }) -}
a1a89eb5c3e343b85b60ab4faac95fa2
  $fOrdErr_$c>= ::
    GHC.Classes.Ord a => ErrM.Err a -> ErrM.Err a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
     Unfolding: (\ @ a
                   ($dOrd :: GHC.Classes.Ord a)
                   (a1 :: ErrM.Err a)
                   (b :: ErrM.Err a) ->
                 case a1 of wild {
                   ErrM.Ok a2
                   -> case b of wild1 {
                        ErrM.Ok b1
                        -> case GHC.Classes.< @ a $dOrd a2 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.True
                             GHC.Types.True -> GHC.Types.False }
                        ErrM.Bad ipv -> GHC.Types.False }
                   ErrM.Bad a2
                   -> case b of wild1 {
                        ErrM.Ok ipv -> GHC.Types.True
                        ErrM.Bad b1
                        -> case GHC.Classes.$fOrd[]_$s$ccompare1 a2 b1 of wild2 {
                             DEFAULT -> GHC.Types.True GHC.Types.LT -> GHC.Types.False } } }) -}
a1a89eb5c3e343b85b60ab4faac95fa2
  $fOrdErr_$ccompare ::
    GHC.Classes.Ord a => ErrM.Err a -> ErrM.Err a -> GHC.Types.Ordering
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U><S,1*U>,
     Unfolding: (\ @ a
                   ($dOrd :: GHC.Classes.Ord a)
                   (a1 :: ErrM.Err a)
                   (b :: ErrM.Err a) ->
                 case a1 of wild {
                   ErrM.Ok a2
                   -> case b of wild1 {
                        ErrM.Ok b1 -> GHC.Classes.compare @ a $dOrd a2 b1
                        ErrM.Bad ipv -> GHC.Types.LT }
                   ErrM.Bad a2
                   -> case b of wild1 {
                        ErrM.Ok ipv -> GHC.Types.GT
                        ErrM.Bad b1 -> GHC.Classes.$fOrd[]_$s$ccompare1 a2 b1 } }) -}
a1a89eb5c3e343b85b60ab4faac95fa2
  $fOrdErr_$cmax ::
    GHC.Classes.Ord a => ErrM.Err a -> ErrM.Err a -> ErrM.Err a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
     Unfolding: (\ @ a
                   ($dOrd :: GHC.Classes.Ord a)
                   (x :: ErrM.Err a)
                   (y :: ErrM.Err a) ->
                 case y of wild {
                   ErrM.Ok a1
                   -> case x of wild1 {
                        ErrM.Ok b1
                        -> case GHC.Classes.< @ a $dOrd a1 b1 of wild2 {
                             GHC.Types.False -> wild GHC.Types.True -> wild1 }
                        ErrM.Bad ipv -> wild1 }
                   ErrM.Bad a1
                   -> case x of wild1 {
                        ErrM.Ok ipv -> wild
                        ErrM.Bad b1
                        -> case GHC.Classes.$fOrd[]_$s$ccompare1 a1 b1 of wild2 {
                             DEFAULT -> wild GHC.Types.LT -> wild1 } } }) -}
a1a89eb5c3e343b85b60ab4faac95fa2
  $fOrdErr_$cmin ::
    GHC.Classes.Ord a => ErrM.Err a -> ErrM.Err a -> ErrM.Err a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
     Unfolding: (\ @ a
                   ($dOrd :: GHC.Classes.Ord a)
                   (x :: ErrM.Err a)
                   (y :: ErrM.Err a) ->
                 case y of wild {
                   ErrM.Ok a1
                   -> case x of wild1 {
                        ErrM.Ok b1
                        -> case GHC.Classes.< @ a $dOrd a1 b1 of wild2 {
                             GHC.Types.False -> wild1 GHC.Types.True -> wild }
                        ErrM.Bad ipv -> wild }
                   ErrM.Bad a1
                   -> case x of wild1 {
                        ErrM.Ok ipv -> wild1
                        ErrM.Bad b1
                        -> case GHC.Classes.$fOrd[]_$s$ccompare1 a1 b1 of wild2 {
                             DEFAULT -> wild1 GHC.Types.LT -> wild } } }) -}
a1a89eb5c3e343b85b60ab4faac95fa2
  $fOrdErr_$cp1Ord ::
    GHC.Classes.Ord a => GHC.Classes.Eq (ErrM.Err a)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a ($dOrd :: GHC.Classes.Ord a) ->
                 ErrM.$fEqErr @ a (GHC.Classes.$p1Ord @ a $dOrd)) -}
a1a89eb5c3e343b85b60ab4faac95fa2
  $fReadErr :: GHC.Read.Read a => GHC.Read.Read (ErrM.Err a)
  DFunId
  {- Arity: 1, Strictness: <L,U(A,A,C(C1(U)),A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: GHC.Read.Read a).
                  @ (ErrM.Err a)
                  (ErrM.$fReadErr_$creadsPrec @ a v)
                  (ErrM.$fReadErr_$creadList @ a v)
                  (ErrM.$fReadErr1 @ a v)
                    `cast`
                  ((<Text.ParserCombinators.ReadPrec.Prec>_R
                    ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                  <ErrM.Err
                                     a>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                       <ErrM.Err a>_R))
                  (ErrM.$fReadErr_$creadListPrec @ a v) -}
a1a89eb5c3e343b85b60ab4faac95fa2
  $fReadErr1 ::
    GHC.Read.Read a =>
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (ErrM.Err a -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 3, Strictness: <L,U(A,A,C(C1(U)),A)><L,U><L,U>,
     Unfolding: (\ @ a
                   ($dRead :: GHC.Read.Read a)
                   (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: ErrM.Err a -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.list3
                   @ (ErrM.Err a)
                   (\ (n :: Text.ParserCombinators.ReadPrec.Prec)
                      @ b1
                      (eta2 :: ErrM.Err a -> Text.ParserCombinators.ReadP.P b1) ->
                    case n of wild { GHC.Types.I# x ->
                    let {
                      karg :: Text.ParserCombinators.ReadP.P b1
                      = case GHC.Prim.<=# x 10# of lwild {
                          DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b1
                          1#
                          -> case Text.Read.Lex.$wexpect
                                    ErrM.$fReadErr_lexeme1
                                    @ b1
                                    (\ (a1 :: ())[OneShot] ->
                                     GHC.Read.list3
                                       @ GHC.Base.String
                                       GHC.Read.$fReadChar2
                                         `cast`
                                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                 <GHC.Base.String>_R))
                                       ErrM.$fReadErr4
                                       @ b1
                                       (\ (a2 :: GHC.Base.String) ->
                                        eta2 (ErrM.Bad @ a a2))) of ww { Unit# ww1 ->
                             Text.ParserCombinators.ReadP.Look @ b1 ww1 } }
                    } in
                    case GHC.Prim.<=# x 10# of lwild {
                      DEFAULT
                      -> Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                           @ b1
                           (Text.ParserCombinators.ReadP.Fail @ b1)
                           karg
                      1#
                      -> case Text.Read.Lex.$wexpect
                                ErrM.$fReadErr_lexeme
                                @ b1
                                (\ (a1 :: ())[OneShot] ->
                                 ((GHC.Read.readPrec @ a $dRead)
                                    `cast`
                                  (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <a>_R)
                                    ErrM.$fReadErr4)
                                   `cast`
                                 (Text.ParserCombinators.ReadP.N:ReadP[0] <a>_R)
                                   @ b1
                                   (\ (a2 :: a) -> eta2 (ErrM.Ok @ a a2))) of ww { Unit# ww1 ->
                         Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                           @ b1
                           (Text.ParserCombinators.ReadP.Look @ b1 ww1)
                           karg } } })
                     `cast`
                   ((<Text.ParserCombinators.ReadPrec.Prec>_R
                     ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                   <ErrM.Err
                                      a>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                        <ErrM.Err a>_R))
                   eta
                   @ b
                   eta1) -}
ac9c5bfd092291e01fd024c17a795278
  $fReadErr2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# ErrM.$fReadErr3) -}
e964655d21dc665f18e5e649932cb9f2
  $fReadErr3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Ok"#) -}
09acd60d46be3b4d27ff8d6f1c47c9c0
  $fReadErr4 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 11#) -}
9ab20c67336e877399d419e6b06ee86a
  $fReadErr5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# ErrM.$fReadErr6) -}
53c6cea9f2dd5a7c79e931feb3eeebce
  $fReadErr6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Bad"#) -}
a1a89eb5c3e343b85b60ab4faac95fa2
  $fReadErr_$creadList ::
    GHC.Read.Read a => Text.ParserCombinators.ReadP.ReadS [ErrM.Err a]
  {- Arity: 1, Strictness: <L,U(A,A,C(C1(U)),A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a ($dRead :: GHC.Read.Read a) ->
                 Text.ParserCombinators.ReadP.run
                   @ [ErrM.Err a]
                   (((GHC.Read.list
                        @ (ErrM.Err a)
                        (ErrM.$fReadErr1 @ a $dRead)
                          `cast`
                        ((<Text.ParserCombinators.ReadPrec.Prec>_R
                          ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                        <ErrM.Err
                                           a>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                             <ErrM.Err a>_R)))
                       `cast`
                     (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <[ErrM.Err a]>_R)
                       GHC.Read.$fRead()7)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0] <[ErrM.Err a]>_R)
                      @ [ErrM.Err a]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ [ErrM.Err a]))) -}
a1a89eb5c3e343b85b60ab4faac95fa2
  $fReadErr_$creadListPrec ::
    GHC.Read.Read a =>
    Text.ParserCombinators.ReadPrec.ReadPrec [ErrM.Err a]
  {- Arity: 1, Strictness: <L,U(A,A,C(C1(U)),A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a ($dRead :: GHC.Read.Read a) ->
                 GHC.Read.list
                   @ (ErrM.Err a)
                   (ErrM.$fReadErr1 @ a $dRead)
                     `cast`
                   ((<Text.ParserCombinators.ReadPrec.Prec>_R
                     ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                   <ErrM.Err
                                      a>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                        <ErrM.Err a>_R))) -}
a1a89eb5c3e343b85b60ab4faac95fa2
  $fReadErr_$creadsPrec ::
    GHC.Read.Read a =>
    GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS (ErrM.Err a)
  {- Arity: 2, Strictness: <L,U(A,A,C(C1(U)),A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dRead :: GHC.Read.Read a) (n :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ (ErrM.Err a)
                   (ErrM.$fReadErr1
                      @ a
                      $dRead
                      n
                      @ (ErrM.Err a)
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ (ErrM.Err a)))) -}
67798845174ad53ade29fea6a19ce5bf
  $fReadErr_lexeme :: Text.Read.Lex.Lexeme
  {- Strictness: m4,
     Unfolding: (Text.Read.Lex.Ident ErrM.$fReadErr2) -}
e279827bef5a64934c5d5507d5d1782c
  $fReadErr_lexeme1 :: Text.Read.Lex.Lexeme
  {- Strictness: m4,
     Unfolding: (Text.Read.Lex.Ident ErrM.$fReadErr5) -}
a1a89eb5c3e343b85b60ab4faac95fa2
  $fShowErr :: GHC.Show.Show a => GHC.Show.Show (ErrM.Err a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: GHC.Show.Show a).
                  @ (ErrM.Err a)
                  (ErrM.$fShowErr_$cshowsPrec @ a v)
                  (ErrM.$fShowErr_$cshow @ a v)
                  (ErrM.$fShowErr_$cshowList @ a v) -}
d5c303e99d32b0defed3c6bdff455f61
  $fShowErr1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
a56df7ef66babdd6bd7d0a642bd2d7c8
  $fShowErr2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Bad "#) -}
a2986afab747cfef0d47a76f9f73ba4f
  $fShowErr3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# ErrM.$fShowErr4) -}
b391feb4f32a89edc9eae80fbbffa298
  $fShowErr4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Ok "#) -}
3039bdce8004156393fc84c27faf3e73
  $fShowErr5 :: [GHC.Types.Char]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Char
                   GHC.Show.$fShow(,)3
                   (GHC.Types.[] @ GHC.Types.Char)) -}
a1a89eb5c3e343b85b60ab4faac95fa2
  $fShowErr_$cshow ::
    GHC.Show.Show a => ErrM.Err a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(1*C1(C1(C1(U))),A,A)><S,1*U>,
     Unfolding: (\ @ a ($dShow :: GHC.Show.Show a) (x :: ErrM.Err a) ->
                 case x of wild {
                   ErrM.Ok b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        ErrM.$fShowErr3
                        (GHC.Show.showsPrec
                           @ a
                           $dShow
                           ErrM.$fReadErr4
                           b1
                           (GHC.Types.[] @ GHC.Types.Char))
                   ErrM.Bad b1
                   -> GHC.CString.unpackAppendCString#
                        ErrM.$fShowErr2
                        (GHC.Types.:
                           @ GHC.Types.Char
                           GHC.Show.$fShow(,)3
                           (GHC.Show.showLitString b1 ErrM.$fShowErr5)) }) -}
a1a89eb5c3e343b85b60ab4faac95fa2
  $fShowErr_$cshowList ::
    GHC.Show.Show a => [ErrM.Err a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ls :: [ErrM.Err a])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (ErrM.Err a)
                   (ErrM.$fShowErr_$cshowsPrec @ a $dShow ErrM.$fShowErr1)
                   ls
                   s) -}
a1a89eb5c3e343b85b60ab4faac95fa2
  $fShowErr_$cshowsPrec ::
    GHC.Show.Show a => GHC.Types.Int -> ErrM.Err a -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Types.Int)
                   (w2 :: ErrM.Err a) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 ErrM.$w$cshowsPrec @ a w ww1 w2 }) -}
dc64928ed5e5b9d5da24c50a0a3a7f7d
  $tc'Bad :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4134202928541793566##
                   3791623417833800849##
                   ErrM.$trModule
                   ErrM.$tc'Bad2
                   1#
                   ErrM.$tc'Bad1) -}
5b53be0d755a2873677263533b6fcc27
  $tc'Bad1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
ae2f305502b456da7fbcac973ddbb61b
  $tc'Bad2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ErrM.$tc'Bad3) -}
4cdb6fad354377c45719fbb79fc91cc4
  $tc'Bad3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Bad"#) -}
73e0f456506f4901443d0fb6322db3fe
  $tc'Ok :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13843046771251217259##
                   16034769855792486254##
                   ErrM.$trModule
                   ErrM.$tc'Ok2
                   1#
                   ErrM.$tc'Ok1) -}
1d8f8348cc189e53ba9f2397d970df16
  $tc'Ok1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
c2a62234fbb8c087f891e35211f3115b
  $tc'Ok2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ErrM.$tc'Ok3) -}
c6ba3f7674f7dca1b12e9f050cd33361
  $tc'Ok3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Ok"#) -}
2eb0fbb2daec7abf629ee6ba216a190e
  $tcErr :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10032327595468837376##
                   14843303223522923265##
                   ErrM.$trModule
                   ErrM.$tcErr1
                   0#
                   GHC.Types.krep$*Arr*) -}
51a38610a9bb186bad654032f4f1d00c
  $tcErr1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ErrM.$tcErr2) -}
d3301a0f1e5cbee42a36eb62cdd305d6
  $tcErr2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Err"#) -}
031603ef838d842898944d76b4b8cd62
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module ErrM.$trModule3 ErrM.$trModule1) -}
936ca3a2bd3e63ef460f66186c704209
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ErrM.$trModule2) -}
e10196d62c3d29aa7e0bc5e04fe616a5
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ErrM"#) -}
25e5ce5407246f687911cfb4f123755a
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ErrM.$trModule4) -}
c4a5681a443b11bfa569d6ff63c27c2c
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("LambdaNat-0.1.0.0-EvitBjaHhSP7BnBJ5PUt9C"#) -}
a1a89eb5c3e343b85b60ab4faac95fa2
  $w$cshowsPrec ::
    GHC.Show.Show a => GHC.Prim.Int# -> ErrM.Err a -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><S,U><S,1*U>,
     Inline: [2],
     Unfolding: (\ @ a
                   (w :: GHC.Show.Show a)
                   (ww :: GHC.Prim.Int#)
                   (w1 :: ErrM.Err a) ->
                 case w1 of wild {
                   ErrM.Ok b1
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ a w ErrM.$fReadErr4 b1
                      } in
                      case GHC.Prim.>=# ww 11# of lwild {
                        DEFAULT
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++ @ GHC.Types.Char ErrM.$fShowErr3 (g x)
                        1#
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.Base.++
                                @ GHC.Types.Char
                                ErrM.$fShowErr3
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))) }
                   ErrM.Bad b1
                   -> case GHC.Prim.>=# ww 11# of lwild {
                        DEFAULT
                        -> \ (x :: GHC.Base.String) ->
                           GHC.CString.unpackAppendCString#
                             ErrM.$fShowErr2
                             (GHC.Types.:
                                @ GHC.Types.Char
                                GHC.Show.$fShow(,)3
                                (GHC.Show.showLitString
                                   b1
                                   (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)3 x)))
                        1#
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.CString.unpackAppendCString#
                                ErrM.$fShowErr2
                                (GHC.Types.:
                                   @ GHC.Types.Char
                                   GHC.Show.$fShow(,)3
                                   (GHC.Show.showLitString
                                      b1
                                      (GHC.Types.:
                                         @ GHC.Types.Char
                                         GHC.Show.$fShow(,)3
                                         (GHC.Types.:
                                            @ GHC.Types.Char
                                            GHC.Show.$fShow(,)2
                                            x))))) } }) -}
a1a89eb5c3e343b85b60ab4faac95fa2
  data Err a = Ok a | Bad GHC.Base.String
instance [safe] GHC.Base.Alternative [ErrM.Err]
  = ErrM.$fAlternativeErr
instance [safe] GHC.Base.Applicative [ErrM.Err]
  = ErrM.$fApplicativeErr
instance [safe] GHC.Classes.Eq [ErrM.Err] = ErrM.$fEqErr
instance [safe] GHC.Base.Functor [ErrM.Err] = ErrM.$fFunctorErr
instance [safe] GHC.Base.Monad [ErrM.Err] = ErrM.$fMonadErr
instance [safe] GHC.Base.MonadPlus [ErrM.Err] = ErrM.$fMonadPlusErr
instance [safe] GHC.Classes.Ord [ErrM.Err] = ErrM.$fOrdErr
instance [safe] GHC.Read.Read [ErrM.Err] = ErrM.$fReadErr
instance [safe] GHC.Show.Show [ErrM.Err] = ErrM.$fShowErr
trusted: safe
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:

